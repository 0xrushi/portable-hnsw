<!DOCTYPE html>
<html lang="en">

<head><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.css">
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Portable HNSW</title>
    <style>
        .container {
            padding: 16px;
            display: flex;
            justify-content: center;
        }
        .inner {
            display: flex;
            justify-content: center;
            flex-direction: column;
            max-width: 1000px;
            width: 100%;
            gap: 20px;
        }
        .query {
            display: flex;
            justify-content: center;
            gap: 12px;
        }
        #text-input {
            flex-grow: 1;
        }
        .path-input {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        #path {
            flex-grow: 1;
        }
    </style>
</head>

<body>
    <main class="container">
        <div class="inner">
            <div class="path-input">
                Path: <input type="text" id="path" value="https://jasonjmcghee.github.io/portable-hnsw/blogs"></input>
            </div>
            <div>
                <div class="query">
                    <textarea id="text-input">falling in love</textarea>
                    <button disabled id="search">Search</button>
                </div>
            <p id="status"></p>
            </div>
            <div id="output"></div>
        </div>
    </main>
    <script type="module">
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0';

        // Since we will download the model from the Hugging Face Hub, we can skip the local model check
        env.allowLocalModels = false;

        // Reference the elements that we will need
        const status = document.getElementById('status');
        const textInput = document.getElementById('text-input');
        const search = document.getElementById('search');
        const output = document.getElementById('output');
        const path = document.getElementById('path');
        let cachedPath = "";
        let conn = null;

        // Create a new feature extraction pipeline
        status.textContent = 'Loading embedding model...';
        const extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
        status.textContent = '';
        search.disabled = false;

        import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/+esm';

        const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();

        // Select a bundle based on browser checks
        const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);

        const worker_url = URL.createObjectURL(
            new Blob([`importScripts("${bundle.mainWorker}");`], {type: 'text/javascript'})
        );

        // Instantiate the asynchronus version of DuckDB-wasm
        const worker = new Worker(worker_url);
        const logger = new duckdb.ConsoleLogger();
        const db = new duckdb.AsyncDuckDB(logger, worker);
        window.db = db;
        await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
        URL.revokeObjectURL(worker_url);

        function euclideanDistanceSquared(arr1, arr2) {
            if (arr1.length !== arr2.length) {
                throw new Error("Arrays must be of the same length");
            }
            let sum = 0;
            for (let i = 0; i < arr1.length; i++) {
                sum += (arr1[i] - arr2[i]) ** 2;
            }
            return sum;
        }

        async function searchWithSql(
            conn,
            queryData,
            k,
            path,
            ef = 10
        ) {
            status.textContent = 'Searching HNSW Index...';

            await db.registerFileURL('docs.parquet', `${path}/docs.parquet`, duckdb.DuckDBDataProtocol.HTTP, false);

            const cache = {};

            const countQuery = `SELECT COUNT(node_id) FROM nodes.parquet`;
            const countResult = await conn.query(countQuery);
            const countArrayed = countResult.toArray().map(([count, _]) => count[1]);
            const count = JSON.parse(countArrayed[0].toString());

            const maxLayer = count > 0 ? Math.floor(Math.log2(count)) : 0;

            const initNodeQuery = `
                SELECT n.node_id, n.data as node_data
                FROM nodes.parquet n
                ORDER BY RANDOM() LIMIT 1
            `;
            let currentBest = await conn.query(initNodeQuery);
            currentBest = currentBest.toArray().map(([nId, data]) => ([nId[1], euclideanDistanceSquared(data[1].data[0].values, queryData)]))

            for (let layer = maxLayer; layer >= 0; layer--) {
                status.textContent = `Searching HNSW Index: ${layer + 1} layers remaining...`;

                let improved = true;
                while (improved) {                    
                    improved = false;
                    const currentNodeIds = currentBest;
                    const candidates = new Set(currentNodeIds);
                    const newCandidates = new Set();

                    const filteredCandidates = Array.from(candidates).filter(nodeId => !cache[nodeId] || !cache[nodeId][layer]);

                    if (filteredCandidates.length === 0) {
                        continue;
                    }

                    const sqlSafeFilteredCandidates = filteredCandidates.join(',');
                    const sqlSafeCandidates = [...candidates, ...Object.keys(cache)].join(',');

                    // Create filtered_edges table
                    const createFilteredEdgesQuery = `
                        DROP TABLE IF EXISTS filtered_edges;
                        CREATE TEMP TABLE filtered_edges AS
                        SELECT * FROM edges.parquet
                        WHERE source_node_id IN (${sqlSafeFilteredCandidates})
                        AND layer = ${layer}
                        AND target_node_id NOT IN (${sqlSafeCandidates});
                    `;
                    await conn.query(createFilteredEdgesQuery);

                    // Perform the join and fetch neighbors
                    const fetchNeighborsQuery = `
                        SELECT 
                            e.target_node_id as node_id, 
                            n.data as node_data
                        FROM nodes.parquet n
                        INNER JOIN filtered_edges e ON n.node_id = e.target_node_id
                    `;
                    const neighbors = (await conn.query(fetchNeighborsQuery)).toArray();


                    if (neighbors.length === 0) {
                        continue;
                    }

                    for (const [neighborId_, node_data_] of neighbors) {
                        const neighborId = neighborId_[1];
                        if (newCandidates.has(neighborId)) {
                            continue;
                        }
                        const data = node_data_[1].data[0].values;
                        let dist;
                
                        if (cache[neighborId] && cache[neighborId].data) {
                            dist = cache[neighborId].distance;
                        } else {
                            dist = euclideanDistanceSquared(data, queryData);
                            cache[neighborId] = { data, distance: dist };
                        }
                        if (currentBest.length < ef || dist < currentBest[currentBest.length - 1][1]) {
                            currentBest.push([neighborId, dist]);
                            newCandidates.add(neighborId);
                            improved = true;
                        }
                    }

                    currentBest.sort((a, b) => a[1] - b[1]);
                    currentBest = currentBest.slice(0, ef);
                }
            }

            const ids = currentBest.slice(0, k).map(([nodeId, _]) => nodeId);
            console.log(ids);

            status.textContent = `Found best candidates. Retrieving documents...`;

            const out = await Promise.all(ids.map(async (id) => {
                const result = await conn.query(`SELECT text FROM read_parquet('${path}/docs.parquet') OFFSET ${id} LIMIT 1`);
                return result.toArray().map(([item]) => item[1])[0];
            }));
            return out;
        }

        async function embed(text) {
            status.textContent = 'Analysing...';
            const out = await extractor(text, { pooling: 'mean', normalize: true });
            status.textContent = '';
            return out;
        }

        search.addEventListener('click', async (e) => {
            const queryData = (await embed(textInput.value)).data;
            status.textContent = 'Searching...';

            if (path.value !== cachedPath) {
                cachedPath = path.value;
                if (conn != null) {
                    await conn.close();
                }
                status.textContent = 'Loading HNSW Index...';
                conn = await db.connect();
                const nodesRes = await fetch(`${cachedPath}/nodes.parquet`);
                await db.registerFileBuffer('nodes.parquet', new Uint8Array(await nodesRes.arrayBuffer()));
                const edgesRes = await fetch(`${cachedPath}/edges.parquet`);
                await db.registerFileBuffer('edges.parquet', new Uint8Array(await edgesRes.arrayBuffer()));
            }

            if (conn == null) {
                conn = await db.connect();
            }

            const out = await searchWithSql(
                // DuckDB
                conn,
                // Embedding
                queryData,
                // K
                5,
                // Path to parquet indices
                cachedPath,
                // EF (the max number of candidate neighbors during search)
                20
            );
            
            status.textContent = '';
            output.innerHTML = out.map((t) => `<p>${t}</p>`).join('')
        });
    </script>
</body>

</html>
